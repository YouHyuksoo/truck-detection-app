import type { OcrLogEntry } from "@/types/logs"
import type { Dataset, Image } from "@/types/dataset"

/**
 * 데이터를 CSV 문자열로 변환
 */
export function convertToCSV(data: OcrLogEntry[]): string {
  if (data.length === 0) return ""

  // CSV 헤더 생성
  const headers = ["ID", "시간", "인식된 숫자", "신뢰도(%)", "관심영역", "처리 시간(ms)", "상태", "PLC 전송", "트럭 ID"]

  // CSV 본문 생성
  const rows = data.map((item) => [
    item.id,
    new Date(item.timestamp).toLocaleString("ko-KR"),
    item.recognizedNumber,
    item.confidence.toString(),
    item.roiName,
    item.processingTime.toString(),
    item.status === "success" ? "성공" : "실패",
    item.sentToPLC ? "전송됨" : "대기중",
    item.truckId || "",
  ])

  // CSV 문자열 생성
  return [headers.join(","), ...rows.map((row) => row.map((cell) => `"${cell.replace(/"/g, '""')}"`).join(","))].join(
    "\n",
  )
}

/**
 * 데이터를 Excel 호환 형식으로 변환 (HTML 테이블 기반)
 */
export function convertToExcel(data: OcrLogEntry[]): string {
  if (data.length === 0) return ""

  // HTML 테이블 헤더 생성
  const headers = ["ID", "시간", "인식된 숫자", "신뢰도(%)", "관심영역", "처리 시간(ms)", "상태", "PLC 전송", "트럭 ID"]

  // HTML 테이블 본문 생성
  const rows = data.map((item) => [
    item.id,
    new Date(item.timestamp).toLocaleString("ko-KR"),
    item.recognizedNumber,
    item.confidence.toString(),
    item.roiName,
    item.processingTime.toString(),
    item.status === "success" ? "성공" : "실패",
    item.sentToPLC ? "전송됨" : "대기중",
    item.truckId || "",
  ])

  // HTML 테이블 생성
  const tableHTML = `
    <html>
      <head>
        <meta charset="UTF-8">
        <style>
          table { border-collapse: collapse; width: 100%; }
          th, td { border: 1px solid #ddd; padding: 8px; }
          th { background-color: #f2f2f2; }
        </style>
      </head>
      <body>
        <table>
          <thead>
            <tr>${headers.map((header) => `<th>${header}</th>`).join("")}</tr>
          </thead>
          <tbody>
            ${rows.map((row) => `<tr>${row.map((cell) => `<td>${cell}</td>`).join("")}</tr>`).join("")}
          </tbody>
        </table>
      </body>
    </html>
  `

  return tableHTML
}

/**
 * 데이터를 JSON 문자열로 변환
 */
export function convertToJSON(data: OcrLogEntry[]): string {
  return JSON.stringify(data, null, 2)
}

/**
 * 데이터셋을 YOLO YAML 형식으로 변환
 */
export function convertToYOLOYAML(
  dataset: Dataset,
  images: Image[],
  trainRatio = 70,
  valRatio = 20,
  testRatio = 10,
  includeTestSplit = false,
): string {
  if (!dataset || images.length === 0) return ""

  // 클래스 이름 추출 (모든 이미지의 어노테이션에서 고유한 레이블 추출)
  const classNames = Array.from(new Set(images.flatMap((img) => img.annotations.map((anno) => anno.label)))).sort()

  // 데이터셋 경로 설정
  const datasetPath = `./datasets/${dataset.name.toLowerCase().replace(/\s+/g, "_")}`

  // 이미지 경로 설정
  const imagesPath = "images"
  const labelsPath = "labels"

  // 학습/검증/테스트 분할
  const totalImages = images.length
  const trainCount = Math.floor(totalImages * (trainRatio / 100))
  const valCount = Math.floor(totalImages * (valRatio / 100))

  // YAML 내용 생성
  let yamlContent = `# YOLOv5 dataset configuration
# Generated by Infinity21 Vision Solution

# Dataset root directory
path: ${datasetPath}

# Train/val/test sets
train: ${imagesPath}/train
val: ${imagesPath}/val
`

  if (includeTestSplit) {
    yamlContent += `test: ${imagesPath}/test\n`
  }

  yamlContent += `
# Classes
nc: ${classNames.length}  # number of classes
names: [${classNames.map((name) => `'${name}'`).join(", ")}]  # class names

# Dataset information
dataset_info:
  name: ${dataset.name}
  description: ${dataset.description || "Generated by Infinity21 Vision Solution"}
  image_count: ${totalImages}
  train_count: ${trainCount}
  val_count: ${valCount}
  ${includeTestSplit ? `test_count: ${totalImages - trainCount - valCount}` : ""}
  created_at: ${dataset.createdAt}
  updated_at: ${dataset.updatedAt}
  tags: [${dataset.tags.map((tag) => `'${tag}'`).join(", ")}]
`

  return yamlContent
}

/**
 * 파일 다운로드 함수
 */
export function downloadFile(data: string, filename: string, mimeType: string): void {
  // Blob 생성
  const blob = new Blob([data], { type: mimeType })

  // 다운로드 링크 생성
  const url = URL.createObjectURL(blob)
  const link = document.createElement("a")
  link.href = url
  link.setAttribute("download", filename)

  // 링크 클릭 이벤트 트리거
  document.body.appendChild(link)
  link.click()

  // 정리
  document.body.removeChild(link)
  URL.revokeObjectURL(url)
}

/**
 * 현재 날짜를 YYYYMMDD 형식으로 반환
 */
export function getFormattedDate(): string {
  const now = new Date()
  const year = now.getFullYear()
  const month = String(now.getMonth() + 1).padStart(2, "0")
  const day = String(now.getDate()).padStart(2, "0")
  return `${year}${month}${day}`
}

/**
 * YOLO 형식의 어노테이션 파일 생성 (단일 이미지용)
 */
export function generateYOLOAnnotation(image: Image, classNames: string[]): string {
  if (!image.annotations || image.annotations.length === 0) return ""

  return image.annotations
    .map((anno) => {
      // 클래스 인덱스 찾기
      const classIndex = classNames.indexOf(anno.label)
      if (classIndex === -1) return ""

      // YOLO 형식으로 변환 [x_center, y_center, width, height] (정규화된 좌표)
      const [x, y, width, height] = anno.bbox
      const x_center = (x + width / 2) / image.width
      const y_center = (y + height / 2) / image.height
      const norm_width = width / image.width
      const norm_height = height / image.height

      // YOLO 형식: <class_index> <x_center> <y_center> <width> <height>
      return `${classIndex} ${x_center.toFixed(6)} ${y_center.toFixed(6)} ${norm_width.toFixed(6)} ${norm_height.toFixed(6)}`
    })
    .join("\n")
}

/**
 * 데이터셋을 YOLO 형식으로 내보내기 위한 ZIP 파일 생성 준비
 * 실제 ZIP 생성은 JSZip 라이브러리 등을 사용해야 함
 */
export function prepareYOLOExport(
  dataset: Dataset,
  images: Image[],
  trainRatio = 70,
  valRatio = 20,
  testRatio = 10,
  includeTestSplit = false,
): {
  yaml: string
  files: Array<{ path: string; content: string }>
} {
  // 클래스 이름 추출
  const classNames = Array.from(new Set(images.flatMap((img) => img.annotations.map((anno) => anno.label)))).sort()

  // YAML 파일 생성
  const yamlContent = convertToYOLOYAML(dataset, images, trainRatio, valRatio, testRatio, includeTestSplit)

  // 이미지 셔플 및 분할
  const shuffledImages = [...images].sort(() => Math.random() - 0.5)

  const totalImages = shuffledImages.length
  const trainCount = Math.floor(totalImages * (trainRatio / 100))
  const valCount = Math.floor(totalImages * (valRatio / 100))

  const trainImages = shuffledImages.slice(0, trainCount)
  const valImages = shuffledImages.slice(trainCount, trainCount + valCount)
  const testImages = shuffledImages.slice(trainCount + valCount)

  // 파일 목록 생성 (실제 구현에서는 이미지 파일도 포함해야 함)
  const files: Array<{ path: string; content: string }> = []

  // 데이터셋 이름 (공백 제거 및 소문자화)
  const datasetDirName = dataset.name.toLowerCase().replace(/\s+/g, "_")

  // YAML 파일 추가
  files.push({
    path: `${datasetDirName}.yaml`,
    content: yamlContent,
  })

  // 학습 데이터 라벨 파일 추가
  trainImages.forEach((img) => {
    const labelContent = generateYOLOAnnotation(img, classNames)
    files.push({
      path: `${datasetDirName}/labels/train/${img.id}.txt`,
      content: labelContent,
    })
  })

  // 검증 데이터 라벨 파일 추가
  valImages.forEach((img) => {
    const labelContent = generateYOLOAnnotation(img, classNames)
    files.push({
      path: `${datasetDirName}/labels/val/${img.id}.txt`,
      content: labelContent,
    })
  })

  // 테스트 데이터 라벨 파일 추가 (옵션)
  if (includeTestSplit) {
    testImages.forEach((img) => {
      const labelContent = generateYOLOAnnotation(img, classNames)
      files.push({
        path: `${datasetDirName}/labels/test/${img.id}.txt`,
        content: labelContent,
      })
    })
  }

  return {
    yaml: yamlContent,
    files,
  }
}
